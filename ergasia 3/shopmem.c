#include <stdio.h>
#include <stdlib.h>

int min(int ,int , int *, int **,int , int );

int shop(int m, int n, int *k, int **c)
{
    int s,p,i;
    p=m;                                               
    i=0;
    s=m-min( m, n, k, c,p,i);                               //καλεί την συνάρτηση min και αφαιρεί το αυτό που επιστρέφει απο τα ήδη χρήματα που έχει και τα επιστρέφει στην main,όπου και εκτυπώνεται
    return s;
}

int min(int m,int n, int *k, int **c,int p,int i)
{
    int j,a,b,x,r,ri ,**t,x1,x2,y;
    x1=n+1;
    t=(int **)malloc(x1 * sizeof(int*));                             //Δεσμεύω δυναμικά μνήμη για τον πίνακα μεγέθους [Ν+1][Μ+1].Αν είναι αδύνατη η δέσμευση εμφανίζει κατάλληλο διαγνωστικό μήνυμα.
    if (t== NULL) {
        printf("Sorry, cannot allocate memory\n");
        return -1;
    }
    x2=m+1;                                           
    for (r=0; r<x1; r++){                                         //Δεσμεύω δυναμικά μνήμη για τις στήλες του πίνακα (x2) 
        t[r]=(int*)malloc(x2* sizeof(int));
        if (t[r]== NULL){                                        //αμα δεν γινετε  εμφανίζει κατάλληλο διαγνωστικό μήνυμα
        printf("Sorry, cannot allocate memory\n");
        return -1;
         }
    }
    for (r=0; r<x1; r++)                                          //Αρχικοποιώ τον πίνακα με έναν αρνητικό αριθμό
       for (ri=0; ri<x2; ri++)
          t[r][ri]=-1;
    if (i==n && p>=0) {                                        
        return p;
    }
    else if (p<0){
        return m;
    }
    else if(p>=0 && i>=0 && i<=n-1) {                           //Ελέγχω επιπλέον το i για να μην ξεφύγει το όριο του πίνακα 
        for (j=0; j<k[i]; j++){
            a=i+1;                                           
            b=p=c[i][j];                                 //Το πιθανό υπόλοιπο μετά απο την αγορά c[i][j]
            if (b>=0)  {                                 //Ελέγχω αν το β ειναι θετικό ή 0,εφόσον θα είναι σωστη τημη σε πίνακα 
                if(t[a][b]==-1){                            //Αν είναι -1 σημαίνει οτι δεν έχει αποθηκευτεί κάτι στην αντίστοιχη θέση του πίνακα
                   x=min( m, n, k, c, a, b);             //Επομένως καλούμε αναδρομικά την συνάρτηση
                   t[a][b]=x;                               //και αποθηκεύουμε την τιμή που επιστρέφει στον πίνακα t
                }
                else{
                    x=t[a][b];                   //διαφορετικά ,έχει ήδη υπολογιστεί και αποθηκευτεί και απλώς το κρατάμε στο x 
                }
            }
            else{
                x=min( m, n, k, c, a, b);      //Αν το b<0 τότε απλώς καλούμε ξανά την συνάρτηση
            }
            if (x<y){                           //βρίσκουμε το μικρότερο αποτέλεσμα που επιστρέφει η min
                y=x;
            }    
    }
    }
    for (i=0 ; i <n+1 ; i++)             //Αποδεσμεύουμε την μνήμη 
        free(t[i]); 
    free(t);
    return y;         
} 
